/*
 * Copyright 2018 Florent Biville (@fbiville)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs

import (
	"fmt"
	"github.com/fbiville/headache/helper"
	"github.com/fbiville/headache/vcs"
	"os"
	"strings"
)

type ExecutionTracker interface {
	ReadLinesAtLastExecutionRevision(path string) (HeaderContents, error)
	GetLastExecutionRevision() (string, error)
}

type HeaderContents struct {
	PreviousLines []string
	CurrentLines  []string
}

type ExecutionVcsTracker struct {
	Versioning vcs.Vcs
	FileSystem FileSystem
	Clock      helper.Clock
}

// returns lines of the specified file at the revision of the last execution of headache
// if headache was never executed, it returns the current contents of the file
func (evt *ExecutionVcsTracker) ReadLinesAtLastExecutionRevision(path string) (HeaderContents, error) {
	bytes, err := evt.FileSystem.FileReader.Read(path)
	if err != nil {
		return HeaderContents{}, err
	}
	currentContents := strings.Split(string(bytes), "\n")
	revision, err := evt.GetLastExecutionRevision()
	if err != nil {
		return HeaderContents{}, err
	}
	if revision == "" {
		return HeaderContents{
			PreviousLines: currentContents,
			CurrentLines:  currentContents}, nil
	}
	contents, err := evt.Versioning.ShowContentAtRevision(path, revision)
	if err != nil {
		return HeaderContents{}, err
	}
	return HeaderContents{
		PreviousLines: strings.Split(contents, "\n"),
		CurrentLines:  currentContents,
	}, nil
}

// returns the revision associated with the last execution of headache
func (evt *ExecutionVcsTracker) GetLastExecutionRevision() (string, error) {
	versioning := evt.Versioning
	root, err := versioning.Root()
	if err != nil {
		return "", err
	}

	path := fmt.Sprintf("%s/%s", root, ".headache-run")

	err = touchOrCreateTrackingFile(path, evt.FileSystem, evt.Clock)
	if err != nil {
		return "", err
	}

	sha, err := versioning.LatestRevision(path)
	if err != nil {
		return "", err
	}
	return sha, nil
}

func touchOrCreateTrackingFile(path string, fileSystem FileSystem, clock helper.Clock) error {
	info, err := fileSystem.FileReader.Stat(path)
	if err == nil && info != nil && !info.Mode().IsRegular() {
		return fmt.Errorf("'%s' should be a regular file", path)
	}
	if err == nil || os.IsNotExist(err) {
		return fileSystem.FileWriter.Write(path, fmt.Sprintf("# Generated by headache | %d -- commit me!", clock.Now().Unix()), 0640)
	}
	return err
}
