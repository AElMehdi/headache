/*
 * Copyright 2018 Florent Biville (@fbiville)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs_test

import (
	"fmt"
	. "github.com/fbiville/headache/fs"
	"github.com/fbiville/headache/fs_mocks"
	"github.com/fbiville/headache/vcs_mocks"
	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	"os"
	"time"
)

var _ = Describe("Execution tracker", func() {
	var (
		t          GinkgoTInterface
		vcs        *vcs_mocks.Vcs
		fileReader *fs_mocks.FileReader
		fileWriter *fs_mocks.FileWriter
		tracker    ExecutionVcsTracker
	)

	BeforeEach(func() {
		t = GinkgoT()
		vcs = new(vcs_mocks.Vcs)
		fileReader = new(fs_mocks.FileReader)
		fileWriter = new(fs_mocks.FileWriter)
		tracker = ExecutionVcsTracker{
			Versioning: vcs,
			FileSystem: FileSystem{FileReader: fileReader, FileWriter: fileWriter},
			Clock:      &FixedClock{},
		}
	})

	AfterEach(func() {
		vcs.AssertExpectations(t)
		fileReader.AssertExpectations(t)
		fileWriter.AssertExpectations(t)
	})

	Describe("when computing last revision", func() {
		It("gets the last execution based on the existing tracker file", func() {
			givenTrackerFileAtRevision(vcs, fileReader, fileWriter, "0xdeadbeef")

			revision, err := tracker.GetLastExecutionRevision()

			Expect(err).To(BeNil())
			Expect(revision).To(Equal("0xdeadbeef"))
		})

		It("gets an empty revision when there is no prior tracker file", func() {
			givenNoTrackerFile(vcs, fileReader, fileWriter)

			revision, err := tracker.GetLastExecutionRevision()

			Expect(err).To(BeNil())
			Expect(revision).To(Equal(""))
		})

		It("propagates versioning root determination error", func() {
			rootError := fmt.Errorf("root error")
			vcs.On("Root").Return("", rootError)

			_, err := tracker.GetLastExecutionRevision()

			Expect(err).To(Equal(rootError))
		})

		It("propagates filesystem stat error", func() {
			fileInfoError := fmt.Errorf("fileinfo error")
			vcs.On("Root").Return("fake-root", nil)
			fileReader.On("Stat", "fake-root/.headache-run").Return(nil, fileInfoError)

			_, err := tracker.GetLastExecutionRevision()

			Expect(err).To(Equal(fileInfoError))
		})

		It("propagates filesystem write error when the tracking file does not exist", func() {
			fileWriteError := fmt.Errorf("oopsie writie")
			vcs.On("Root").Return("fake-root", nil)
			fileReader.On("Stat", "fake-root/.headache-run").Return(nil, os.ErrNotExist)
			fileWriter.On("Write", "fake-root/.headache-run", "# Generated by headache | 42 -- commit me!", os.FileMode(0640)).Return(fileWriteError)

			_, err := tracker.GetLastExecutionRevision()

			Expect(err).To(Equal(fileWriteError))
		})

		It("propagates filesystem touch error on the existing tracking file", func() {
			touch := fmt.Errorf("touch error")
			vcs.On("Root").Return("fake-root", nil)
			fileReader.On("Stat", "fake-root/.headache-run").Return(&FakeFileInfo{FileMode: 0777}, nil)
			fileWriter.On("Write", "fake-root/.headache-run", "# Generated by headache | 42 -- commit me!", os.FileMode(0640)).Return(touch)

			_, err := tracker.GetLastExecutionRevision()

			Expect(err).To(Equal(touch))
		})

		It("propagates last versioning revision retrieval error", func() {
			latestRevisionError := fmt.Errorf("latest revision error")
			vcs.On("Root").Return("fake-root", nil)
			fileReader.On("Stat", "fake-root/.headache-run").Return(&FakeFileInfo{FileMode: 0777}, nil)
			fileWriter.On("Write", "fake-root/.headache-run", "# Generated by headache | 42 -- commit me!", os.FileMode(0640)).Return(nil)
			vcs.On("LatestRevision", "fake-root/.headache-run").Return("", latestRevisionError)

			_, err := tracker.GetLastExecutionRevision()

			Expect(err).To(Equal(latestRevisionError))
		})
	})

	Describe("when reading lines at a specific revision", func() {
		It("succeeds at doing so without prior tracker file", func() {
			givenNoTrackerFile(vcs, fileReader, fileWriter)
			headerFile := "some-header"
			fileReader.On("Read", headerFile).
				Return([]byte("some very important notice\nthat noone will actually read #sadpanda"), nil)

			contents, err := tracker.ReadLinesAtLastExecutionRevision(headerFile)

			Expect(err).To(BeNil())
			Expect(contents.PreviousLines).To(Equal(contents.CurrentLines))
			Expect(contents.CurrentLines).To(Equal([]string{
				"some very important notice",
				"that noone will actually read #sadpanda",
			}))
		})

		It("succeeds at doing so with a prior tracker file", func() {
			revision := "0xcafebabe"
			givenTrackerFileAtRevision(vcs, fileReader, fileWriter, revision)
			headerFile := "some-header"
			vcs.On("ShowContentAtRevision", headerFile, revision).
				Return("a somewhat important notice\nI hope will actually read it #foreveroptimism", nil)
			fileReader.On("Read", headerFile).
				Return([]byte("some very important notice\nthat noone will actually read #sadpanda"), nil)

			contents, err := tracker.ReadLinesAtLastExecutionRevision(headerFile)

			Expect(err).To(BeNil())
			Expect(contents.PreviousLines).To(Equal([]string{
				"a somewhat important notice",
				"I hope will actually read it #foreveroptimism",
			}))
			Expect(contents.CurrentLines).To(Equal([]string{
				"some very important notice",
				"that noone will actually read #sadpanda",
			}))
		})

		It("propagates filesystem read error", func() {
			headerFile := "some-header"
			readError := fmt.Errorf("read error")
			fileReader.On("Read", headerFile).Return(nil, readError)

			_, err := tracker.ReadLinesAtLastExecutionRevision(headerFile)

			Expect(err).To(Equal(readError))
		})

		It("propagates versioning errors without prior tracker file", func() {
			revision := "0xcafebabe"
			givenTrackerFileAtRevision(vcs, fileReader, fileWriter, revision)
			headerFile := "some-header"
			fileReader.On("Read", headerFile).
				Return([]byte("some very important notice\nthat noone will actually read #sadpanda"), nil)
			versioningError := fmt.Errorf("versioning error")
			vcs.On("ShowContentAtRevision", headerFile, revision).Return("", versioningError)

			_, err := tracker.ReadLinesAtLastExecutionRevision(headerFile)

			Expect(err).To(Equal(versioningError))
		})

		It("propagates tracker file versioning revision retrieval error", func() {
			headerFile := "some-header"
			fileReader.On("Read", headerFile).
				Return([]byte("some very important notice\nthat noone will actually read #sadpanda"), nil)
			vcsRootError := fmt.Errorf("root error")
			vcs.On("Root").Return("", vcsRootError)

			_, err := tracker.ReadLinesAtLastExecutionRevision(headerFile)

			Expect(err).To(Equal(vcsRootError))
		})
	})
})

func givenTrackerFileAtRevision(vcs *vcs_mocks.Vcs, fileReader *fs_mocks.FileReader, fileWriter *fs_mocks.FileWriter, revision string) {
	vcs.On("Root").Return("fake-root", nil)
	fileReader.On("Stat", "fake-root/.headache-run").Return(&FakeFileInfo{FileMode: 0777}, nil)
	fileWriter.On("Write", "fake-root/.headache-run", "# Generated by headache | 42 -- commit me!", os.FileMode(0640)).Return(nil)
	vcs.On("LatestRevision", "fake-root/.headache-run").Return(revision, nil)
}

func givenNoTrackerFile(vcs *vcs_mocks.Vcs, fileReader *fs_mocks.FileReader, fileWriter *fs_mocks.FileWriter) {
	vcs.On("Root").Return("fake-root", nil)
	fileReader.On("Stat", "fake-root/.headache-run").Return(nil, os.ErrNotExist)
	fileWriter.On("Write", "fake-root/.headache-run", "# Generated by headache | 42 -- commit me!", os.FileMode(0640)).Return(nil)
	vcs.On("LatestRevision", "fake-root/.headache-run").Return("", nil)
}

type FixedClock struct{}

func (*FixedClock) Now() time.Time {
	return time.Unix(42, 42)
}
